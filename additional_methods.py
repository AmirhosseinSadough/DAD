# -*- coding: utf-8 -*-
"""Outlier Detection using Indegree Number (ODIN) Algorithm
"""
# Author: Roel Bouman <roel.bouman@ru.nl>
# License: BSD 2 clause

from __future__ import division
from __future__ import print_function

from sklearn.neighbors import kneighbors_graph
from sklearn.utils.validation import check_is_fitted
from sklearn.utils.validation import check_array

from pyod.models.base import BaseDetector
from pyod.utils.utility import invert_order

import numpy as np

#Note, PREDICT is not implemented properly yet. It looks only to 1 matrix of input data at a time.
class ODIN(BaseDetector):
      """Connectivity-Based Outlier Factor (COF) COF uses the ratio of average
    chaining distance of data point and the average of average chaining
    distance of k nearest neighbor of the data point, as the outlier score
    for observations.

    See :cite:`` for details.
    
    Two version of COF are supported:

    - Fast COF: computes the entire pairwise distance matrix at the cost of a
      O(n^2) memory requirement.
    - Memory efficient COF: calculates pairwise distances incrementally.
      Use this implementation when it is not feasible to fit the n-by-n 
      distance in memory. This leads to a linear overhead because many 
      distances will have to be recalculated.

    Parameters
    ----------
    contamination : float in (0., 0.5), optional (default=0.1)
        The amount of contamination of the data set, i.e.
        the proportion of outliers in the data set. Used when fitting to
        define the threshold on the decision function.

    n_neighbors : int, optional (default=20)
        Number of neighbors to use by default for k neighbors queries.
        Note that n_neighbors should be less than the number of samples.
        If n_neighbors is larger than the number of samples provided,
        all samples will be used.
        
    method : string, optional (default='fast')
        Valid values for method are:
            
        - 'fast' Fast COF, computes the full pairwise distance matrix up front.
        - 'memory' Memory-efficient COF, computes pairwise distances only when
          needed at the cost of computational speed.

    Attributes
    ----------
    decision_scores_ : numpy array of shape (n_samples,)
        The outlier scores of the training data.
        The higher, the more abnormal. Outliers tend to have higher
        scores. This value is available once the detector is
        fitted.

    threshold_ : float
        The threshold is based on ``contamination``. It is the
        ``n_samples * contamination`` most abnormal samples in
        ``decision_scores_``. The threshold is calculated for generating
        binary outlier labels.

    labels_ : int, either 0 or 1
        The binary labels of the training data. 0 stands for inliers
        and 1 for outliers/anomalies. It is generated by applying
        ``threshold_`` on ``decision_scores_``.

    n_neighbors_: int
        Number of neighbors to use by default for k neighbors queries.
    """ 

    def __init__(self, n_neighbors=20,
                 metric='minkowski', p=2, metric_params=None,
                 contamination=0.1, n_jobs=None):
        super(ODIN, self).__init__(contamination=contamination)
        self.n_neighbors = n_neighbors
        self.metric = metric
        self.p = p
        self.metric_params = metric_params
        self.n_jobs = n_jobs


    def fit(self, X, y=None):
        """Fit detector. y is ignored in unsupervised methods.
        Parameters
        ----------
        X : numpy array of shape (n_samples, n_features)
            The input samples.
        y : Ignored
            Not used, present for API consistency by convention.
        Returns
        -------
        self : object
            Fitted estimator.
        """
        # validate inputs X and y (optional)
        X = check_array(X)

        self.knn_graph_  = kneighbors_graph(X, n_neighbors=self.n_neighbors,
                                            metric=self.metric,
                                            p=self.p,
                                            metric_params=self.metric_params,
                                            n_jobs=self.n_jobs,
                                            include_self=False)
        
        
        
        

        # Invert decision_scores_. Outliers comes with higher outlier scores
        self.decision_scores_ = invert_order(np.asarray(np.sum(self.knn_graph_, axis=0)).flatten())
        self._process_decision_scores()
        return self

    def decision_function(self, X):
        """TEMP
        """
        X = check_array(X)

        self.knn_graph_  = kneighbors_graph(X, n_neighbors=self.n_neighbors,
                                            metric=self.metric,
                                            p=self.p,
                                            metric_params=self.metric_params,
                                            n_jobs=self.n_jobs,
                                            include_self=False)   
        
        
        

        # Invert decision_scores_. Outliers comes with higher outlier scores
        self.decision_scores_ = invert_order(np.asarray(np.sum(self.knn_graph_, axis=0)).flatten())
        self._process_decision_scores()
